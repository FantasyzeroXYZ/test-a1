
import { SubtitleLine, AudioTrack } from '../types';

export const parseSRT = (content: string): SubtitleLine[] => {
  const subtitles: SubtitleLine[] = [];
  const blocks = content.trim().replace(/\r\n/g, '\n').split('\n\n');

  blocks.forEach((block, index) => {
    const lines = block.split('\n');
    if (lines.length >= 2) {
      const timecodeLine = lines.find(l => l.includes('-->'));
      if (!timecodeLine) return;

      const [startStr, endStr] = timecodeLine.split('-->').map(s => s.trim());
      
      const parseTime = (t: string) => {
        const [hms, ms] = t.split(/[,.]/); 
        const parts = hms.split(':').map(Number);
        let s = 0;
        if (parts.length === 3) {
            s = parts[0] * 3600 + parts[1] * 60 + parts[2];
        } else if (parts.length === 2) {
            s = parts[0] * 60 + parts[1];
        }
        return s + Number(ms || 0) / 1000;
      };

      const start = parseTime(startStr);
      const end = parseTime(endStr);
      
      const textStartIndex = lines.indexOf(timecodeLine) + 1;
      const text = lines.slice(textStartIndex).join(' ').replace(/<[^>]*>/g, '');

      subtitles.push({
        id: `srt-${index}`,
        start,
        end,
        text
      });
    }
  });
  return subtitles;
};

export const parseVTT = (content: string): SubtitleLine[] => {
    const cleanContent = content.replace(/^WEBVTT.*\n/, '');
    return parseSRT(cleanContent);
};

export const parseLRC = (content: string): SubtitleLine[] => {
  const subtitles: SubtitleLine[] = [];
  const lines = content.split('\n');
  const regex = /\[(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?\](.*)/;

  lines.forEach((line, index) => {
    const match = line.match(regex);
    if (match) {
      const minutes = parseInt(match[1], 10);
      const seconds = parseInt(match[2], 10);
      const msStr = match[3];
      const text = match[4].trim();
      
      let milliseconds = 0;
      if (msStr) {
        const ms = parseInt(msStr, 10);
        milliseconds = msStr.length === 2 ? ms * 10 : ms;
      }
      
      const time = minutes * 60 + seconds + milliseconds / 1000;

      if (index > 0 && subtitles.length > 0) {
        subtitles[subtitles.length - 1].end = time;
      }
      
      subtitles.push({
        id: `lrc-${index}`,
        start: time,
        end: time + 10,
        text
      });
    }
  });
  return subtitles;
};

export const parseASS = (content: string): SubtitleLine[] => {
    const subtitles: SubtitleLine[] = [];
    const lines = content.split('\n');
    lines.forEach(line => {
        if (line.startsWith("Dialogue:")) {
            const parts = line.replace("Dialogue: ", "").split(",");
            if (parts.length < 10) return;
            const parseTime = (t: string) => {
                const [h, m, s] = t.split(":").map(Number);
                return h * 3600 + m * 60 + s;
            };
            const start = parseTime(parts[1]);
            const end = parseTime(parts[2]);
            const text = parts.slice(9).join(",").replace(/\{[^}]+\}/g, '').replace(/\\N/g, ' ');
            subtitles.push({
                id: `ass-${subtitles.length}`,
                start,
                end,
                text: text.trim()
            });
        }
    });
    return subtitles;
};

export const formatTime = (seconds: number): string => {
  if (isNaN(seconds)) return "0:00";
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  if (h > 0) {
    return `${h}:${m < 10 ? '0' : ''}${m}:${s < 10 ? '0' : ''}${s}`;
  }
  return `${m}:${s < 10 ? '0' : ''}${s}`;
};

export const exportTrackToMarkdown = (track: AudioTrack): string => {
  let md = `# Study Notes: ${track.title}\n\n`;
  md += `| Metadata | Value |\n`;
  md += `| :--- | :--- |\n`;
  md += `| Source | ${track.filename || 'Remote Stream'} |\n`;
  md += `| Duration | ${formatTime(track.duration || 0)} |\n`;
  md += `| Created At | ${new Date().toLocaleString()} |\n\n`;

  if (track.bookmarks && track.bookmarks.length > 0) {
    md += `## ğŸ”– Bookmarks & Study Notes\n\n`;
    track.bookmarks.sort((a, b) => a.time - b.time).forEach(bm => {
      // ä½¿ç”¨ HTML span æ ‡ç­¾æ¥æ ‡è®°é¢œè‰²ï¼ŒMarkdown æœ¬èº«ä¸æ”¯æŒç›´æ¥é¢œè‰²
      const colorIndicator = bm.color ? `<span style="color:${bm.color};">â—</span>` : "";
      md += `### ğŸ•’ [${formatTime(bm.time)}] ${bm.label} ${colorIndicator}\n`;
      if (bm.notes) {
        md += `> ${bm.notes.replace(/\n/g, '\n> ')}\n\n`;
      }
      md += `\n`;
    });
  } else {
    md += `*No specific bookmarks added for this session.*\n`;
  }

  md += `\n---\n*Generated by LinguaFlow Player*`;
  return md;
};

export const downloadFile = (content: string, fileName: string, mimeType: string) => {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
